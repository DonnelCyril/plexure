## Entities

### CouponDefinition

|Field Name|Type|
|---------|-----|
|CouponDefinitionId|Guid|
|Title|String|
|StartDate|Date|
|EndDate|Date|
|MaximumNumberOfCouponsPerUser|Integer|
|MaximumNumberOfCoupons|Integer|

### CouponRedemption

|Field Name|Type|Notes|
|---------|-----|-----|
|CouponRedemptionId|Guid|Unique id generated by the application when a coupon is redeemed|
|RedemptionDate|DateTime|
|CouponDefinitionId|Guid|
|UserId|Guid|


### UserCouponRedemption

|Field Name|Type|Notes|
|---------|-----|
|CouponDefinitionId|Guid|
|UserId|Guid|
|RedemptionCount|Integer|Total number of redemtpions made by the user for the coupon identified by the *CouponDefinitionId* field.


## Overview
For the given requirements, we could leverage Cosmos DB in Azure as a backend datastore for the Coupon management system. Key motivation for selecting Cosmos DB is the considerable price savings in comparison to a SQL cluster, while at the same time providing for a scalable and highly available data storage environment.<br>
We will have a single database that is configured for multi-region read writes for high availablity. Each of the entities will be created as an individual container within the database.

## Queries
### 1. Provide a list of active coupons
- This can be retrieved by querying the CouponDefinition collection.
- By default all fields are indexed, however for the current requirement we only need the *EndDate* field to be indexed.
- CouponDefinitionId will be used as the partition key for the collection.

### 2. Determine if a customer can redeem a coupon
The assumption here is that there are two requirements to be met before a user can redeem a coupon:
  1. Total number of coupon redemptions is less than or equal to *MaximumNumberOfCoupons* field in the coupon definition.
  2. Total number of coupon redemptions for a *user* is less than or equal to *MaximumNumberOfCouponsPerUser* field in the coupon definition.

Solutions for *requirment 1* are discussed further below. To meet *requirement 2*, we maintain a *UserCouponRedemption* record for each *user*, *coupon* combination.
When a request is made to redeem a coupon:
1. We first check this record to determine the number of existing redemptions by a user.
2. We then proceed to increment and update the redemption count for the user.
3. Cosmos DB provides an *etag* field for every document which can be used for *optimistic concurrency* checks.

*Requirement 2* requires use to keep an exact count of the number of redemption per coupon. This is a hard problem in a high volume distributed environment. Few solutions are proposed below:
##### 1. Not enforcing a strict count on the total redemptions per coupon
- In this model we keep an in memory count of the number or redemptions made for an active coupon.
- This list is periodically updated by a background task. We can leverage the *change feed* feature of Cosmos DB to calculate this count.
- A request to redeem a coupon will be checked against this in-memory count before proceeding further.
- The disadvantage with this approach is that we could potentially over redeem a coupon during a small window, but may be an acceptable compromise by the business.

##### 2. Pregenerate a list of *CouponRedemption* entries for a coupon
- In this model, the coupon redemptions entries for a coupon are pre-populated.
- The *CouponRedemptionId* and *RedemptionDate* fields for the record will be empty initially.
- When redeeming a coupon, we fetch a record with an empty *CouponRedemptionId* and update the *CouponRedemptionId* and *RedemptionDate* fields accordingly.
- *CouponRedemptionId* field will be indexed to make this query efficient.
- If the system is used alongside a *shopping cart*, where a redemption involves first adding the coupon to the cart and then redeeming it as part of payment, a separate field could be added to track this *Reserved* status which will then be updated to *Confirmed*.
- Key considerations: The above model ensures that we dont over redeem coupons. The requirement to pre-populate *CouponRedemption* entries has some implications which should be considered.
    - Upfront cost of provisioning these records. This may mean that we will have to run with a higher *RU* allocation than would be otherwise required. However if we operate in a model where the *Coupons* are created in advance before it goes on sale, this pre-generation could be scheduled to a non-busy period for the system.
    - A coupon may not be used to its full capacity, this would result in a lot of empty records and increased space consumption. We could provision these records with a *Time To Live (TTL)* setting that is set to expire when the coupon expires, or alternatively we could have a clean up job to remove the unused entries.

##### 3. Adopt a single writer approach
- The key issue we are facing here is that it is hard to keep an accurate count when there are concurrent writes.
- If we serialize these writes, then a single writer could keep track of the coupon redemption count.
- The challenge is that this approach wont scale in high workload environment.
- One approach is to shard the number of redemptions for a coupon across multiple nodes. Say for eg: a coupon has 1000 redemptions, then Node A can do upto 500 redemptions and Node B does the rest.
- We will require a smart router fronting these nodes, that can route the request based on the Coupon.
- Key considerations:
    - This approach has the best of both worlds - preventing over redemptions and keeping the Cosmos DB cost minimal
    - However this comes with increased operational and development overhead.

We can tweak and adopt these approaches to best fit the business model. If we can allow for some amount of over-redemptions then option 1 is preferred, followed by options 2 and 3.

### 3. Store redemptions as they occur
- Every redemption will create a *CouponRedemption* record after populating the required fields.

### 4. Provide reporting on the redemptions for a specific offer
While a typical SQL model will allow for adhoc reports after the schema has been defined, the desired query patterns needs to be thought upfront with a NoSQL design.
Some assumptions made here:
- We need to report on the total redemptions for a coupon
- The redemptions made should be reported per week or day or another unit of time as desired.

For one of the above queries, we need to keep track of the total redemption count per coupon. The *Change feed* feature in Cosmos DB helps us to keep a running total of this count. We could persist this information for the desired time frame, as a new record to help with reporting. A background process will then use this information to generate a *materialised view* needed for the report in a desired time scheduled.

